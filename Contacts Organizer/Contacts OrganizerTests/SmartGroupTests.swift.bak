//
//  SmartGroupTests.swift
//  Contacts OrganizerTests
//
//  Unit tests for smart group generation logic
//

import XCTest
@testable import Contacts_Organizer

final class SmartGroupTests: XCTestCase {

    // MARK: - Organization Grouping

    func testOrganizationGrouping() {
        let contacts = [
            ContactSummary(id: "1", fullName: "John Smith", organization: "Apple", phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "2", fullName: "Jane Doe", organization: "Apple", phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "3", fullName: "Bob Johnson", organization: "Google", phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "4", fullName: "Alice Williams", organization: "Google", phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil)
        ]

        let definition = SmartGroupDefinition(name: "By Organization", groupingType: .organization)
        let results = ContactsManager.shared.generateSmartGroups(definitions: [definition], using: contacts)

        XCTAssertEqual(results.count, 2, "Should create 2 organization groups")
        XCTAssertTrue(results.contains { $0.groupName == "Apple" }, "Should have Apple group")
        XCTAssertTrue(results.contains { $0.groupName == "Google" }, "Should have Google group")
    }

    func testOrganizationGroupingMinimumTwoContacts() {
        let contacts = [
            ContactSummary(id: "1", fullName: "John Smith", organization: "Apple", phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "2", fullName: "Jane Doe", organization: "Google", phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil)
        ]

        let definition = SmartGroupDefinition(name: "By Organization", groupingType: .organization)
        let results = ContactsManager.shared.generateSmartGroups(definitions: [definition], using: contacts)

        XCTAssertEqual(results.count, 0, "Should not create groups with only 1 contact")
    }

    // MARK: - Custom Criteria - Has Phone

    func testCustomCriteriaHasPhone() {
        let contacts = [
            ContactSummary(id: "1", fullName: "John Smith", organization: nil, phoneNumbers: ["555-1234"], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "2", fullName: "Jane Doe", organization: nil, phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil)
        ]

        let criteria = CustomCriteria(rules: [
            CustomCriteria.Rule(field: .hasPhone, condition: .exists)
        ])
        let definition = SmartGroupDefinition(name: "Has Phone", groupingType: .custom(criteria))
        let results = ContactsManager.shared.generateSmartGroups(definitions: [definition], using: contacts)

        XCTAssertEqual(results.count, 1, "Should create one group")
        XCTAssertEqual(results.first?.contacts.count, 1, "Should contain one contact with phone")
        XCTAssertEqual(results.first?.contacts.first?.id, "1", "Should be the contact with phone")
    }

    // MARK: - Custom Criteria - Missing Email

    func testCustomCriteriaMissingEmail() {
        let contacts = [
            ContactSummary(id: "1", fullName: "John Smith", organization: nil, phoneNumbers: ["555-1234"], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "2", fullName: "Jane Doe", organization: nil, phoneNumbers: [], emailAddresses: ["jane@example.com"], hasProfileImage: false, creationDate: nil, modificationDate: nil)
        ]

        let criteria = CustomCriteria(rules: [
            CustomCriteria.Rule(field: .hasEmail, condition: .notExists)
        ])
        let definition = SmartGroupDefinition(name: "Missing Email", groupingType: .custom(criteria))
        let results = ContactsManager.shared.generateSmartGroups(definitions: [definition], using: contacts)

        XCTAssertEqual(results.count, 1, "Should create one group")
        XCTAssertEqual(results.first?.contacts.count, 1, "Should contain one contact without email")
        XCTAssertEqual(results.first?.contacts.first?.id, "1", "Should be the contact without email")
    }

    // MARK: - Custom Criteria - Multiple Rules

    func testCustomCriteriaMultipleRules() {
        let contacts = [
            ContactSummary(id: "1", fullName: "John Smith", organization: nil, phoneNumbers: ["555-1234"], emailAddresses: ["john@example.com"], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "2", fullName: "Jane Doe", organization: nil, phoneNumbers: ["555-5678"], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "3", fullName: "Bob Johnson", organization: nil, phoneNumbers: [], emailAddresses: ["bob@example.com"], hasProfileImage: false, creationDate: nil, modificationDate: nil)
        ]

        let criteria = CustomCriteria(rules: [
            CustomCriteria.Rule(field: .hasPhone, condition: .exists),
            CustomCriteria.Rule(field: .hasEmail, condition: .exists)
        ])
        let definition = SmartGroupDefinition(name: "Complete Contacts", groupingType: .custom(criteria))
        let results = ContactsManager.shared.generateSmartGroups(definitions: [definition], using: contacts)

        XCTAssertEqual(results.count, 1, "Should create one group")
        XCTAssertEqual(results.first?.contacts.count, 1, "Should contain one contact with both phone and email")
        XCTAssertEqual(results.first?.contacts.first?.id, "1", "Should be the complete contact")
    }

    // MARK: - Custom Criteria - Organization Contains

    func testCustomCriteriaOrganizationContains() {
        let contacts = [
            ContactSummary(id: "1", fullName: "John Smith", organization: "Apple Inc.", phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "2", fullName: "Jane Doe", organization: "Apple Store", phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "3", fullName: "Bob Johnson", organization: "Google", phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil)
        ]

        let criteria = CustomCriteria(rules: [
            CustomCriteria.Rule(field: .organizationContains, condition: .contains, value: "Apple")
        ])
        let definition = SmartGroupDefinition(name: "Apple Contacts", groupingType: .custom(criteria))
        let results = ContactsManager.shared.generateSmartGroups(definitions: [definition], using: contacts)

        XCTAssertEqual(results.count, 1, "Should create one group")
        XCTAssertEqual(results.first?.contacts.count, 2, "Should contain two contacts with Apple in organization")
    }

    // MARK: - Custom Criteria - Name Contains

    func testCustomCriteriaNameContains() {
        let contacts = [
            ContactSummary(id: "1", fullName: "John Smith", organization: nil, phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "2", fullName: "Johnny Doe", organization: nil, phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "3", fullName: "Bob Johnson", organization: nil, phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil)
        ]

        let criteria = CustomCriteria(rules: [
            CustomCriteria.Rule(field: .nameContains, condition: .contains, value: "John")
        ])
        let definition = SmartGroupDefinition(name: "John Contacts", groupingType: .custom(criteria))
        let results = ContactsManager.shared.generateSmartGroups(definitions: [definition], using: contacts)

        XCTAssertEqual(results.count, 1, "Should create one group")
        XCTAssertEqual(results.first?.contacts.count, 2, "Should contain two contacts with John in name")
    }

    // MARK: - Custom Criteria - Has Photo

    func testCustomCriteriaHasPhoto() {
        let contacts = [
            ContactSummary(id: "1", fullName: "John Smith", organization: nil, phoneNumbers: [], emailAddresses: [], hasProfileImage: true, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "2", fullName: "Jane Doe", organization: nil, phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil)
        ]

        let criteria = CustomCriteria(rules: [
            CustomCriteria.Rule(field: .hasPhoto, condition: .exists)
        ])
        let definition = SmartGroupDefinition(name: "Has Photo", groupingType: .custom(criteria))
        let results = ContactsManager.shared.generateSmartGroups(definitions: [definition], using: contacts)

        XCTAssertEqual(results.count, 1, "Should create one group")
        XCTAssertEqual(results.first?.contacts.count, 1, "Should contain one contact with photo")
        XCTAssertEqual(results.first?.contacts.first?.id, "1", "Should be the contact with photo")
    }

    // MARK: - Multiple Definitions

    func testMultipleDefinitions() {
        let contacts = [
            ContactSummary(id: "1", fullName: "John Smith", organization: "Apple", phoneNumbers: ["555-1234"], emailAddresses: ["john@example.com"], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "2", fullName: "Jane Doe", organization: "Apple", phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil)
        ]

        let definitions = [
            SmartGroupDefinition(name: "By Organization", groupingType: .organization),
            SmartGroupDefinition(name: "Complete Contacts", groupingType: .custom(CustomCriteria(rules: [
                CustomCriteria.Rule(field: .hasPhone, condition: .exists),
                CustomCriteria.Rule(field: .hasEmail, condition: .exists)
            ])))
        ]

        let results = ContactsManager.shared.generateSmartGroups(definitions: definitions, using: contacts)

        XCTAssertEqual(results.count, 2, "Should create groups for both definitions")
    }

    // MARK: - Disabled Definitions

    func testDisabledDefinitionsNotGenerated() {
        let contacts = [
            ContactSummary(id: "1", fullName: "John Smith", organization: "Apple", phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "2", fullName: "Jane Doe", organization: "Apple", phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil)
        ]

        let definition = SmartGroupDefinition(name: "By Organization", groupingType: .organization, isEnabled: false)
        let results = ContactsManager.shared.generateSmartGroups(definitions: [definition], using: contacts)

        XCTAssertEqual(results.count, 0, "Should not generate groups for disabled definitions")
    }

    // MARK: - Phase 1 Smart Groups

    func testPhase1NoCriticalInfo() {
        let contacts = [
            ContactSummary(id: "1", fullName: "John Smith", organization: nil, phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "2", fullName: "Jane Doe", organization: nil, phoneNumbers: ["555-1234"], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "3", fullName: "Bob Johnson", organization: nil, phoneNumbers: [], emailAddresses: ["bob@example.com"], hasProfileImage: false, creationDate: nil, modificationDate: nil)
        ]

        let criteria = CustomCriteria(rules: [
            CustomCriteria.Rule(field: .noCriticalInfo, condition: .exists)
        ])
        let definition = SmartGroupDefinition(name: "Missing Critical Info", groupingType: .custom(criteria))
        let results = ContactsManager.shared.generateSmartGroups(definitions: [definition], using: contacts)

        XCTAssertEqual(results.count, 1, "Should create one group")
        XCTAssertEqual(results.first?.contacts.count, 1, "Should contain one contact with no phone or email")
        XCTAssertEqual(results.first?.contacts.first?.id, "1", "Should be the contact with no critical info")
    }

    func testPhase1PhoneOnly() {
        let contacts = [
            ContactSummary(id: "1", fullName: "John Smith", organization: nil, phoneNumbers: ["555-1234"], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "2", fullName: "Jane Doe", organization: nil, phoneNumbers: [], emailAddresses: ["jane@example.com"], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "3", fullName: "Bob Johnson", organization: nil, phoneNumbers: ["555-5678"], emailAddresses: ["bob@example.com"], hasProfileImage: false, creationDate: nil, modificationDate: nil)
        ]

        let criteria = CustomCriteria(rules: [
            CustomCriteria.Rule(field: .phoneOnly, condition: .exists)
        ])
        let definition = SmartGroupDefinition(name: "Phone Only", groupingType: .custom(criteria))
        let results = ContactsManager.shared.generateSmartGroups(definitions: [definition], using: contacts)

        XCTAssertEqual(results.count, 1, "Should create one group")
        XCTAssertEqual(results.first?.contacts.count, 1, "Should contain one contact with phone only")
        XCTAssertEqual(results.first?.contacts.first?.id, "1", "Should be the contact with phone only")
    }

    func testPhase1EmailOnly() {
        let contacts = [
            ContactSummary(id: "1", fullName: "John Smith", organization: nil, phoneNumbers: ["555-1234"], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "2", fullName: "Jane Doe", organization: nil, phoneNumbers: [], emailAddresses: ["jane@example.com"], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "3", fullName: "Bob Johnson", organization: nil, phoneNumbers: ["555-5678"], emailAddresses: ["bob@example.com"], hasProfileImage: false, creationDate: nil, modificationDate: nil)
        ]

        let criteria = CustomCriteria(rules: [
            CustomCriteria.Rule(field: .emailOnly, condition: .exists)
        ])
        let definition = SmartGroupDefinition(name: "Email Only", groupingType: .custom(criteria))
        let results = ContactsManager.shared.generateSmartGroups(definitions: [definition], using: contacts)

        XCTAssertEqual(results.count, 1, "Should create one group")
        XCTAssertEqual(results.first?.contacts.count, 1, "Should contain one contact with email only")
        XCTAssertEqual(results.first?.contacts.first?.id, "2", "Should be the contact with email only")
    }

    func testPhase1MultiplePhones() {
        let contacts = [
            ContactSummary(id: "1", fullName: "John Smith", organization: nil, phoneNumbers: ["555-1234", "555-5678"], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "2", fullName: "Jane Doe", organization: nil, phoneNumbers: ["555-9999"], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "3", fullName: "Bob Johnson", organization: nil, phoneNumbers: ["555-1111", "555-2222", "555-3333"], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil)
        ]

        let criteria = CustomCriteria(rules: [
            CustomCriteria.Rule(field: .multiplePhones, condition: .exists)
        ])
        let definition = SmartGroupDefinition(name: "Multiple Phones", groupingType: .custom(criteria))
        let results = ContactsManager.shared.generateSmartGroups(definitions: [definition], using: contacts)

        XCTAssertEqual(results.count, 1, "Should create one group")
        XCTAssertEqual(results.first?.contacts.count, 2, "Should contain two contacts with multiple phones")
        XCTAssertTrue(results.first?.contacts.contains { $0.id == "1" } ?? false, "Should include contact 1")
        XCTAssertTrue(results.first?.contacts.contains { $0.id == "3" } ?? false, "Should include contact 3")
    }

    func testPhase1MultipleEmails() {
        let contacts = [
            ContactSummary(id: "1", fullName: "John Smith", organization: nil, phoneNumbers: [], emailAddresses: ["john@work.com", "john@personal.com"], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "2", fullName: "Jane Doe", organization: nil, phoneNumbers: [], emailAddresses: ["jane@example.com"], hasProfileImage: false, creationDate: nil, modificationDate: nil),
            ContactSummary(id: "3", fullName: "Bob Johnson", organization: nil, phoneNumbers: [], emailAddresses: ["bob1@example.com", "bob2@example.com", "bob3@example.com"], hasProfileImage: false, creationDate: nil, modificationDate: nil)
        ]

        let criteria = CustomCriteria(rules: [
            CustomCriteria.Rule(field: .multipleEmails, condition: .exists)
        ])
        let definition = SmartGroupDefinition(name: "Multiple Emails", groupingType: .custom(criteria))
        let results = ContactsManager.shared.generateSmartGroups(definitions: [definition], using: contacts)

        XCTAssertEqual(results.count, 1, "Should create one group")
        XCTAssertEqual(results.first?.contacts.count, 2, "Should contain two contacts with multiple emails")
        XCTAssertTrue(results.first?.contacts.contains { $0.id == "1" } ?? false, "Should include contact 1")
        XCTAssertTrue(results.first?.contacts.contains { $0.id == "3" } ?? false, "Should include contact 3")
    }

    // MARK: - Phase 2 Time-Based Smart Groups

    func testPhase2RecentlyAdded() {
        let now = Date()
        let twentyDaysAgo = Calendar.current.date(byAdding: .day, value: -20, to: now)!
        let fortyDaysAgo = Calendar.current.date(byAdding: .day, value: -40, to: now)!

        let contacts = [
            ContactSummary(id: "1", fullName: "John Smith", organization: nil, phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: twentyDaysAgo, modificationDate: nil),
            ContactSummary(id: "2", fullName: "Jane Doe", organization: nil, phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: fortyDaysAgo, modificationDate: nil)
        ]

        let criteria = CustomCriteria(rules: [
            CustomCriteria.Rule(field: .recentlyAdded, condition: .exists)
        ])
        let definition = SmartGroupDefinition(name: "Recently Added", groupingType: .custom(criteria))
        let results = ContactsManager.shared.generateSmartGroups(definitions: [definition], using: contacts)

        XCTAssertEqual(results.count, 1, "Should create one group")
        XCTAssertEqual(results.first?.contacts.count, 1, "Should contain one recently added contact")
        XCTAssertEqual(results.first?.contacts.first?.id, "1", "Should be contact added 20 days ago")
    }

    func testPhase2RecentlyModified() {
        let now = Date()
        let tenDaysAgo = Calendar.current.date(byAdding: .day, value: -10, to: now)!
        let sixtyDaysAgo = Calendar.current.date(byAdding: .day, value: -60, to: now)!

        let contacts = [
            ContactSummary(id: "1", fullName: "John Smith", organization: nil, phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: tenDaysAgo),
            ContactSummary(id: "2", fullName: "Jane Doe", organization: nil, phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: sixtyDaysAgo)
        ]

        let criteria = CustomCriteria(rules: [
            CustomCriteria.Rule(field: .recentlyModified, condition: .exists)
        ])
        let definition = SmartGroupDefinition(name: "Recently Modified", groupingType: .custom(criteria))
        let results = ContactsManager.shared.generateSmartGroups(definitions: [definition], using: contacts)

        XCTAssertEqual(results.count, 1, "Should create one group")
        XCTAssertEqual(results.first?.contacts.count, 1, "Should contain one recently modified contact")
        XCTAssertEqual(results.first?.contacts.first?.id, "1", "Should be contact modified 10 days ago")
    }

    func testPhase2StaleContacts() {
        let now = Date()
        let twoYearsAgo = Calendar.current.date(byAdding: .year, value: -2, to: now)!
        let threeMonthsAgo = Calendar.current.date(byAdding: .month, value: -3, to: now)!

        let contacts = [
            ContactSummary(id: "1", fullName: "John Smith", organization: nil, phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: twoYearsAgo),
            ContactSummary(id: "2", fullName: "Jane Doe", organization: nil, phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: threeMonthsAgo)
        ]

        let criteria = CustomCriteria(rules: [
            CustomCriteria.Rule(field: .staleContact, condition: .exists)
        ])
        let definition = SmartGroupDefinition(name: "Stale Contacts", groupingType: .custom(criteria))
        let results = ContactsManager.shared.generateSmartGroups(definitions: [definition], using: contacts)

        XCTAssertEqual(results.count, 1, "Should create one group")
        XCTAssertEqual(results.first?.contacts.count, 1, "Should contain one stale contact")
        XCTAssertEqual(results.first?.contacts.first?.id, "1", "Should be contact not modified in 2 years")
    }

    func testPhase2BirthdayThisMonth() {
        let calendar = Calendar.current
        let now = Date()
        let currentMonth = calendar.component(.month, from: now)
        let currentYear = calendar.component(.year, from: now)

        // Create birthday in this month
        var thisMonthComponents = DateComponents()
        thisMonthComponents.year = currentYear - 30
        thisMonthComponents.month = currentMonth
        thisMonthComponents.day = 15
        let thisMonthBirthday = calendar.date(from: thisMonthComponents)!

        // Create birthday in different month
        var otherMonthComponents = DateComponents()
        otherMonthComponents.year = currentYear - 25
        otherMonthComponents.month = (currentMonth % 12) + 1
        otherMonthComponents.day = 20
        let otherMonthBirthday = calendar.date(from: otherMonthComponents)!

        let contacts = [
            ContactSummary(id: "1", fullName: "John Smith", organization: nil, phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil, birthday: thisMonthBirthday),
            ContactSummary(id: "2", fullName: "Jane Doe", organization: nil, phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil, birthday: otherMonthBirthday)
        ]

        let criteria = CustomCriteria(rules: [
            CustomCriteria.Rule(field: .birthdayThisMonth, condition: .exists)
        ])
        let definition = SmartGroupDefinition(name: "Birthday This Month", groupingType: .custom(criteria))
        let results = ContactsManager.shared.generateSmartGroups(definitions: [definition], using: contacts)

        XCTAssertEqual(results.count, 1, "Should create one group")
        XCTAssertEqual(results.first?.contacts.count, 1, "Should contain one contact with birthday this month")
        XCTAssertEqual(results.first?.contacts.first?.id, "1", "Should be contact with birthday this month")
    }

    func testPhase2BirthdayThisWeek() {
        let calendar = Calendar.current
        let now = Date()

        // Get current week interval
        guard let weekInterval = calendar.dateInterval(of: .weekOfYear, for: now) else {
            XCTFail("Could not get week interval")
            return
        }

        // Create birthday within this week (use middle of week)
        let midWeek = Date(timeInterval: weekInterval.duration / 2, since: weekInterval.start)
        let currentYear = calendar.component(.year, from: now)

        var thisWeekComponents = DateComponents()
        thisWeekComponents.year = currentYear - 30
        thisWeekComponents.month = calendar.component(.month, from: midWeek)
        thisWeekComponents.day = calendar.component(.day, from: midWeek)
        let thisWeekBirthday = calendar.date(from: thisWeekComponents)!

        // Create birthday outside this week
        let nextWeek = calendar.date(byAdding: .weekOfYear, value: 1, to: now)!
        var nextWeekComponents = DateComponents()
        nextWeekComponents.year = currentYear - 25
        nextWeekComponents.month = calendar.component(.month, from: nextWeek)
        nextWeekComponents.day = calendar.component(.day, from: nextWeek)
        let nextWeekBirthday = calendar.date(from: nextWeekComponents)!

        let contacts = [
            ContactSummary(id: "1", fullName: "John Smith", organization: nil, phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil, birthday: thisWeekBirthday),
            ContactSummary(id: "2", fullName: "Jane Doe", organization: nil, phoneNumbers: [], emailAddresses: [], hasProfileImage: false, creationDate: nil, modificationDate: nil, birthday: nextWeekBirthday)
        ]

        let criteria = CustomCriteria(rules: [
            CustomCriteria.Rule(field: .birthdayThisWeek, condition: .exists)
        ])
        let definition = SmartGroupDefinition(name: "Birthday This Week", groupingType: .custom(criteria))
        let results = ContactsManager.shared.generateSmartGroups(definitions: [definition], using: contacts)

        XCTAssertEqual(results.count, 1, "Should create one group")
        XCTAssertEqual(results.first?.contacts.count, 1, "Should contain one contact with birthday this week")
        XCTAssertEqual(results.first?.contacts.first?.id, "1", "Should be contact with birthday this week")
    }

    // MARK: - Default Smart Groups

    func testDefaultSmartGroups() {
        let defaults = ContactsManager.defaultSmartGroups

        XCTAssertTrue(defaults.count > 0, "Should have default smart group definitions")
        XCTAssertTrue(defaults.allSatisfy { $0.isEnabled }, "All default groups should be enabled")
    }

    // MARK: - Empty Contact List

    func testEmptyContactList() {
        let contacts: [ContactSummary] = []
        let definition = SmartGroupDefinition(name: "By Organization", groupingType: .organization)
        let results = ContactsManager.shared.generateSmartGroups(definitions: [definition], using: contacts)

        XCTAssertEqual(results.count, 0, "Should return empty results for empty contact list")
    }
}
